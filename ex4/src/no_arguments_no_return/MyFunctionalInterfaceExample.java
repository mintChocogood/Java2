package no_arguments_no_return;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class MyFunctionalInterfaceExample {

	// 핵심포인트: 람다식의 타겟타입에 선언된 추상메소드의 형태에 따라,
	//			   람다식의 생략조건이 점점 증가!!
	public static void main(String[] args) {
		// 1. 함수적 인터페이스 타입의 참조변수 선언

		MyFunctionalInterfaceExample obj = new MyFunctionalInterfaceExample();
		log.info("1. obj: {}", obj);
		obj.인턴메소드();
		
		MyFunctionalInterface3 fi2 = null;
		MyFunctionalInterface fi = null;

		// 2. "익명구현객코딩기법"을 활용하여,
		//    함수적 인터페이스에 선언된 추상메소드를 재정의(override)
		// 	  하는 "익명구현객체"를 생성해봅니다!
		
		class TTT{ // class block 
			
		} // end class
		
		fi = new MyFunctionalInterface() {	// 자식 구현객체 => 다형성-1

			@Override
			public void method() {
				log.trace("메소드 호출됨");
				
			}  // 메소드
			
		}; // 익명구현객체 생성(익명구현클래스의 class block)
		log.info("1. fi: {}", fi);
		fi.method(); 	// 다형성-2: 부모타입인 인터페이스의 추상메소드를 호출하면
						//			 => 실제 저장된 익명자식구현객체의 재정의된
						//				메소드가 호출된다!(부모의 메소드를 hidding)
		
		// =========================================================================== //
		// 함수적인터페이스에 대한, 익명구현객체를 생성하는 두번째 방법
		// =========================================================================== //
		// 람다식(Lambda Expression) 을 이용해서, 위 첫번째와 동일한
		// "익명구현객체"를 생성해보자!!!
		// 아래의 단계대로 잘 따라서 하시면, 더 쉽게 적응되실 겁니다:
		//	Step.1 함수적 인터페이스에 선언된, 단 1개의 추상메소드를 그대로 복사
		//		   하고 주석으로 넣습니다
		//	Step.2 Step.1 에서 복사해온 추상메소드 시그니처에서, "매개변수선언부"만
		//		   떼어오자!!!
		//	Step.3 Step.2 에서 가져온 "매개변수선언부" 오른쪽에 화살표 기호('->')를
		//		   붙여주장!!
		//	Step.4 Step3에서 붙인 화살표 기호 오른쪽에 "중괄호 블록"을 만들자!!
		// 	Step.5 람다식도 하나의 실행문장이니, 세미콜론(';')으로 마감합시다!
		//	Step.6 Step.5까지 구현된 완전한 람다식을, 함수적 인터페이스 타입의 변수에
		//		   그대로 저장하자!!!!
		// =========================================================================== //
		
		// Step.1 : public abstract void method();
		
		// Step.2, Step.3
		// 이 중괄호 블록이 바로 "추상메소드"의 "메소드 블록"
		fi = () -> { 
			log.trace("method() 호출됨.");
		};	// 다형성-1
		
		log.info("2. fi: {}", fi);
		fi.method();		// 다형성-2
		
		// =========================================================================== //
		// 람다식의 생략문법에 대해서 익히자!!!
		// =========================================================================== //
		// (1) 람다식의 중광호 블록({}) 내에, 실행문장이 오직 1개밖에 없으면,
		//	   중괄호 기호({})를 생략 할 수 있따!!!
		// (2) 람다식의 매개변수 선언부에 매개변수들의 타입들을 생략할 수 있다.
		// (3) 람다식의 매개변수선언부에 매개변수 개수가 오직 1개 밖에 없으면,
		//	   소괄호기호(())를 생략할 수 있다.
		// (4) 람다식의 타겟타입에 선언된 추상메소드가 리턴타입이 있는 경우,
		//	   중괄호 블록안의 실행문장이 오직 1개밖에 없고, 그 문장이 return
		//     문인 경우, 위의 생략조건 (1)에 따라 중괄호 생략하고,
		//     return 키워드는 무조건 생략해야 한다.
		// =========================================================================== //
		
		// 표현식: (1) 리터럴 (2) 변수 (3) 리턴타입이 있는 메소드 호출 (4) 연산식
		// 1 개만 남은 실행문장이, 오직 표현식(값을 생성하는 식) 이라면,
		// 그 앞에 return 키워드가 생략된 것이다!
		
		// ---------- 클로져(Closure) 문제 발생 및 해결책------------ //
		// final 상수는, 이 실행 클래스에 대한 Clazz 객체의 "상수풀(Constant Pool)"
		// 영역으로 들어간다!! => 즉, Clazz 객체의 생명주기를 가진다 =>
		// Clazz 객체의 생명주기는 JVM의 생명주기와 같다!
		 String name = "기서";
		 int age = 28;
		 
		 double weight = 58.9; // 람다식에서 사용안함
		
		
			fi2 = (x,y) -> {
				log.trace("메소드 ({}, {}) 실행됨." ,x, y);
				
				// 지역변수 사용
				// 사용한 지역변수는, main 메소드 블록이 끝나면, 바로 파괴!!
				log.info("name: {}, age: {}", name, age);
				log.info("this: {}");
				
				return x + y;
			};	// 힙에 생성되는 익명구현객체 생성
				
//			name = "트리니티";			// XX : 컴파일 오류 (수정불가)
//			age = 23;					// XX : 컴파일 오류 (수정불가)
//			weight = 23.2;				// OK : 람다식 내부에서 사용하지 않은 지역변수
										// 		그저 그냥 지역변수 => 곧 파괴
			
		
		
		
		
		
			
		
	} // main
	
	public void 인턴메소드() {
		MyFunctionalInterface3 fi2 = null;
		String name = "기서";
		 int age = 28;
		
		fi2 = (x,y) -> {
			log.trace("메소드 ({}, {}) 실행됨." ,x, y);
			
			// 지역변수 사용
			// 사용한 지역변수는, main 메소드 블록이 끝나면, 바로 파괴!!
			log.info("name: {}, age: {}", name, age);
			log.info("this: {}");
			
			return x + y;
		};	// 힙에 생성되는 익명구현객체 생성
	} // 인스턴스 메소드
} // end class
